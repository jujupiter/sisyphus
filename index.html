<html>
	<head>
		<meta charset="utf-8">
		<title>SISYphus</title>
		<style>
			body{
				background: #002 url("cosmos.jpg") no-repeat center center;
			}
			div#playground{
				width: 350px;
				height: 350px;
				position: absolute;
				top:0;
				bottom: 0;
				left: 0;
				right: 0;
				margin: auto;
			}
		</style>
		<script src="http://d3js.org/d3.v3.min.js"></script>
		<script src="http://d3js.org/queue.v1.min.js"></script>
		<script src="http://d3js.org/topojson.v1.min.js"></script>
	</head>
	<body>
		<div id="playground"></div>
		<script>
			var diameter = 350,
				width = diameter,
				height = diameter,
				x = 0,
				y = 0;

			var projection = d3.geo.orthographic()
				.scale(diameter/2)
				.translate([width / 2, height / 2])
				.clipAngle(90);

			var canvas = d3.select("div#playground").append("canvas")
				.attr("width", width)
				.attr("height", height);

			var c = canvas.node().getContext("2d");

			var path = d3.geo.path()
				.projection(projection)
				.context(c);
				
			var paused = false;
			  
			var index=0;
			var knownLocations = [];
			var unknownLocations = [];
			var land = null;
			var globe = {type: "Sphere"};
			var albums = [];

			queue()
				.defer(d3.json, "political.json")
				.defer(d3.json, "https://picasaweb.google.com/data/feed/api/user/jujupiter?alt=json")
				.defer(d3.json, "location.php?action=listing")
				.await(ready);
				
			function ready(error, world, albums, loadedLocations) {
			    knownLocations = loadedLocations.locations;
			    land = topojson.feature(world, world.objects.land);
			    albums = albums.feed.entry;
			    for(var i=0; i<albums.length; i++) {
					if(albums[i]['gphoto$location']['$t']!="") {
						var isKnown = false;
						for(var j=0; j<knownLocations.length; j++) {
							if(knownLocations[j].name==albums[i]['gphoto$location']['$t']) {
								isKnown = true;
								if(!knownLocations[j].hasOwnProperty('albums')) {
									knownLocations[j].albums = [];
								}
								knownLocations[j].albums.push(albums[i]);
								break;
							}
						}
						if(!isKnown && unknownLocations.indexOf(albums[i]['gphoto$location']['$t'])==-1) {
							unknownLocations.push(albums[i]['gphoto$location']['$t']);
						}
					}
			    }
				if(unknownLocations.length > 0) {
					// Start recurring calls to get all missing locations
					d3.json("http://maps.google.com/maps/api/geocode/json?address="+unknownLocations[0], requestingCoordinates);
				}
				else {
					// Display the globe
					console.log(knownLocations);
					order();
				}
			}
			
			function requestingCoordinates(error, results) {
			
				if(error) console.error(error);
				
				// List matching albums
				var matchingAlbums = [];
				for(var i=0; i<albums.length; i++) {
					if(unknownLocations[index]==albums[i]['gphoto$location']['$t']) {
						matchingAlbums.push(albums[i]);
					}
				}
				
				// At least one result has been found
				if(results.results.length>0) {
					var tLng = results.results[0].geometry.location.lng;
					var tLat = results.results[0].geometry.location.lat;
					// Add to list of known locations
					knownLocations.push({
						name: unknownLocations[index],
						// We only take the first result
						lat: tLat,
						lng: tLng,
						invalid: false,
						albums: matchingAlbums
					});
					// Save location into local database
					d3.json("location.php?action=add&name="+unknownLocations[index]+"&lat="+tLat+"&lng="+tLng, function() {});
				}
				
				// No match found, location is regarded as invalid
				else {
					knownLocations.push({
						name: unknownLocations[index],
						lat: null,
						lng: null,
						invalid: true,
						albums: matchingAlbums
					});
					// Declare as invalid
					d3.json("location.php?action=add&name="+unknownLocations[index]+"&lat=&lng=", function() {});
				}
				index++;
				if(index+1>=unknownLocations.length) {
					console.log(knownLocations);
					order();
				}
				else {
					d3.json("http://maps.google.com/maps/api/geocode/json?address="+unknownLocations[index], requestingCoordinates);
				}
			}
			
			// Order cities by latitude and put those in the northern hemisphere in one array, those in the souther hemisphere in another array
			var northHemisphere = [];
			var southHemisphere = [];
			
			function order() {
				for(var i=0; i<knownLocations.length; i++) {
					if(!knownLocations[i].invalid && knownLocations[i].hasOwnProperty('albums') && knownLocations[i].albums.length>0) {
						var target = null;
						if(knownLocations[i].lat < 0) {
							targetHemisphere = southHemisphere;
						}
						else {
							targetHemisphere = northHemisphere;
						}
						// We order positions by longitude, thus we define the position where the city should be added
						var position = 0;
						for(var j=0; j<targetHemisphere.length; j++) {
							if(targetHemisphere[j].lng < knownLocations[i].lng) {
								position = j+1;
							}
							else {
								break;
							}
						}
						targetHemisphere.splice(position, 0, knownLocations[i]);
					}
				}
				transition();
			}
			
			var selectedPositions = {
				north: [],
				south: []
			};
			var observableUniverse = {
				min: null,
				max: null,
				north: [],
				south: [],
				update: function() {
					this.min = 90-x;
					this.max = 270-x;
					this.north = this.filter(northHemisphere);
					this.south = this.filter(southHemisphere);
				},
				isVisible: function(lng) {
					return (lng <= this.min || lng >= this.max);
				},
				filter: function(hemisphere) {
					var filtered = [];
					for(var i=0; i<hemisphere.length; i++) {
						if(observableUniverse.isVisible(hemisphere[i].lng)) {
							filtered.push(hemisphere[i]);
						}
					}
					return filtered;
				}
			};
			
			function isAlreadySelected(hemisphere, position) {
				for(var i=0;i<selectedPositions[hemisphere].length; i++) {
					if(selectedPositions[hemisphere][i]==position) {
						return true;
					}
				}
				return false;
			}
			
			function selectPositions(hemisphere, index) {
				if(!selectedPositions[hemisphere][index] || !observableUniverse.isVisible(selectedPositions[hemisphere][index].lng)) {
					// Pick randomly a position
					var pool = observableUniverse[hemisphere];
					var newIndex = Math.floor(Math.random()*(pool.length-0.00001));
					if(!isAlreadySelected(hemisphere, pool[newIndex])) {
						selectedPositions[hemisphere][index] = pool[newIndex];
					}
				}
			}
			
			function transition() {
				d3.transition()
					.duration(30)
					.tween("rotate", function() {
						if(!paused) {
						  x += 1;
						  if(x>360) {
							x = 0;
						  }
						  observableUniverse.update();
						  var r = d3.interpolate(projection.rotate(), [x, y]);
						  // 2. Compute top items, left and right (right becomes left when left is out of range and right is determines as longitude is bigger than left's longitude and in the visuable range)
						  // 3. Compute bottoms items, left and right (right becomes left when left disappears and right is determines as longitude is bigger than left's longitude and in the visuable range)
						  return function(t) {
							projection.rotate(r(t));
							c.clearRect(0, 0, width, height);
							// Sea
							c.fillStyle = '#111177';
							c.beginPath();
							c.arc(width/2, height/2, height/2, 0, 2 * Math.PI, false);
							c.fill();
							// Land
							c.fillStyle = "#55ee22";
							c.beginPath();
							path(land);
							c.fill();
							// Landmarks
							//displayLandmarks();
							// Cities
							/*for(var i=0;i<knownLocations.length;i++) {
								if(!knownLocations[i].invalid && knownLocations[i].hasOwnProperty('albums') && knownLocations[i].albums.length>0) {
									setOnMap(knownLocations[i]);
								}
							}*/
							// Cities from different hemispheres
							/*var nL = Math.min(x, northHemisphere.length);
							for(var i=0;i<northHemisphere.length;i++) {
								setOnMap(northHemisphere[i], '#ff0');
							}
							var sL = Math.min(x, southHemisphere.length);
							for(var i=0;i<southHemisphere.length;i++) {
								setOnMap(southHemisphere[i], '#f00');
							}*/
							// Define the 4 selected positions : either they are empty or not in the observable universe anymore
							
							
							/*if(!selectedPositions.NE || !observableUniverse.isVisible(selectedPositions.NE.lng)) {
								// Pick randomly a position
								var iterations = Math.round(Math.random()*10);
								var select = null;
								for(var i=0; i<iterations; i++) {
									var superIterations = Math.floor(Math.random()*northHemisphere.length);
									for(var j=0; j<superIterations; j++) {
										if(observableUniverse.isVisible(northHemisphere[j].lng) && northHemisphere[j].lng < 0) {
											selected = northHemisphere[j];
										}
									}
								}
								selectedPositions.NW = selected;
							}*/
							selectPositions('north', 0);
							selectPositions('north', 1);
							selectPositions('south', 0);
							selectPositions('south', 1);
							setOnMap(selectedPositions['north'][0], '#ff0');
							setOnMap(selectedPositions['north'][1], '#ff0');
							setOnMap(selectedPositions['south'][0], '#ff0');
							setOnMap(selectedPositions['south'][1], '#ff0');
						  };
						}
					})
				  .transition()
					.each("end", transition);
			}
			
			function displayLandmarks() {
				c.strokeStyle = "#0ff";
				c.beginPath();
				c.moveTo(width/2, 0);
				c.lineTo(width/2, height);
				c.stroke();
				c.beginPath();
				c.moveTo(0, height/2);
				c.lineTo(width, height/2);
				c.stroke();
			}
			
			function setOnMap(position, color) {
				if(position && position.lng && position.lat) {
					if(!color) {
						color = "#fff";
					}
					c.fillStyle = color;
					c.beginPath();
					var city = {
						type: "Feature",
						properties: {},
						geometry : {
						  "type": "Point",
						  "coordinates": [position.lng, position.lat]
						}
					};
					path(city);
					c.fill();
				}
			}
			
			function isVisible(lng, name) {
				return (x+lng<=90 || x+lng>=270);
			}
			
			function pause() {
				paused = !paused;
			}
		</script>
		<a href="javascript:pause()">Pause</a>
	</body>
</html>